---
title: 增加、修改和删除
description: 
published: true
date: 2021-02-25T15:30:15.025Z
tags: django
editor: markdown
dateCreated: 2021-02-25T15:30:15.025Z
---

# 增

```python
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self):
        return self.name

class Author(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()

    def __str__(self):
        return self.name

class Entry(models.Model):
    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField()
    authors = models.ManyToManyField(Author)
    number_of_comments = models.IntegerField()
    number_of_pingbacks = models.IntegerField()
    rating = models.IntegerField()

    def __str__(self):
        return self.headline
```

## save()

Django 仅当在显式调用 save() 才操作数据库。其背后执行了 `INSERT SQL` 语句

```python
>>> from blog.models import Blog
>>> b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
>>> b.save()
```

## create()

创建一个对象并一步到位地保存

```python
>>> Author.objects.create(name="Jack", email="admin@admin.com")
<Author: Jack>
```

与下面的方式等价：

```python
a = Author(name="Jack", email="admin@admin.com")
a.save(force_insert=True) # 强制执行 INSERT
```

## bulk_create()

将所提供的对象列表以高效的方式插入到数据库中

```python
>>> a1 = Author(name = 'Mike',email = 'mike@qq.com')
>>> a2 = Author(name = 'Tom',email = 'tom@163.com')
>>> Author.objects.bulk_create([a1,a2])
[<Author: Mike>, <Author: Tom>]
```

> 有关注意事项参考[官方文档](https://docs.djangoproject.com/zh-hans/3.1/ref/models/querysets/#bulk-create)
{.is-success}

该方法有一个 batch_size 参数控制在一次查询中创建多少对象，默认情况是在一个批次中创建所有对象，但 SQLite 除外，默认情况是每个查询最多使用 999 个变量。

## get_or_create()

一个简便的方法，用于查找特定对象，不存在则创建。

常用来防止在并行进行请求时创建重复的对象，例如：

```python
try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
except Person.DoesNotExist:
    obj = Person(first_name='John', last_name='Lennon', birthday=date(1940, 10, 9))
    obj.save()
```

如果是并发请求，可能会多次尝试用相同的参数保存一个 Person。为了避免这种竞争条件，可以使用 get_or_create() 重写上面的例子，比如：

```python
obj, created = Person.objects.get_or_create(
    first_name='John',
    last_name='Lennon',
    defaults={'birthday': date(1940, 10, 9)},
)
```

返回 `(object, created)` 的元组，其中 object 是检索或创建的对象，created 是指定是否创建新对象的布尔值。

- 如果找到了一个对象，则 `get_or_create()` 返回该对象的元组和 False。

- 如果找到多个对象，get_or_create() 会引发 `MultipleObjectsReturned`

- 如果没有找到对象，返回一个新对象的元组和 True

> 如果关键字参数中使用的字段有唯一性约束，这个方法是**原子性**的。否则并发调用可能会导致插入具有相同参数的多条记录。
{.is-warning}


**一个复杂的案例**

如果 Robert 或 Bob Marley 存在，则检索 Robert 或 Bob Marley，否则创建后者：

```python
from django.db.models import Q

obj, created = Person.objects.filter(
    Q(first_name='Bob') | Q(first_name='Robert'),
).get_or_create(last_name='Marley', defaults={'first_name': 'Bob'})
```

> 官方推荐只在 POST 请求中使用它，因为 GET 请求不应该对数据有任何影响。
{.is-success}

> 通过 ManyToManyField 属性和反向关系来使用 get_or_create()。在这种情况下，你将限制在该关系的上下文内进行查询。如果你不持续使用它，这可能会导致一些完整性问题。
{.is-warning}

例如：

```python
class Chapter(models.Model):
    title = models.CharField(max_length=255, unique=True)

class Book(models.Model):
    title = models.CharField(max_length=256)
    chapters = models.ManyToManyField(Chapter)
```

可以通过 Book 的 chapters 字段使用 get_or_create()，但它只能在该书的上下文中获取：

```python
>>> book = Book.objects.create(title="Ulysses")
>>> book.chapters.get_or_create(title="Telemachus")
(<Chapter: Telemachus>, True)
>>> book.chapters.get_or_create(title="Telemachus")
(<Chapter: Telemachus>, False)
>>> Chapter.objects.create(title="Chapter 1") # 这一行导致下面出现异常
<Chapter: Chapter 1>
>>> book.chapters.get_or_create(title="Chapter 1")
# Raises IntegrityError 抛出异常
```

# 改

## update_or_create()

用给定的 kwargs 更新对象的一种方便方法，是必要时创建一个新对象。defaults 是用来更新对象的 (field, value) 对的字典。defaults 中的值可以是可调用对象。

具体的含义与注意事项与 get_or_update() 一样。

例如：

```python
defaults = {'first_name': 'Bob'}
try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
    for key, value in defaults.items():
        setattr(obj, key, value)
    obj.save()
except Person.DoesNotExist:
    new_values = {'first_name': 'John', 'last_name': 'Lennon'}
    new_values.update(defaults)
    obj = Person(**new_values)
    obj.save()
```

上面的例子可以使用 update_or_create() 重写

```python
obj, created = Person.objects.update_or_create(
    first_name='John', last_name='Lennon',
    defaults={'first_name': 'Bob'},
)
```

## update()

对指定的字段执行 SQL 更新查询，并返回匹配的行数

例如，要关闭 2010 年发表的所有博客条目的评论：

```python
Entry.objects.filter(pub_date__year=2010).update(comments_on=False)
```

如果只是更新一条记录，不需要对模型对象做任何事情，最有效的方法是调用 update()，而不是将模型对象加载到内存中。例如，不要这样做：

```python
e = Entry.objects.get(id=10)
e.comments_on = False
e.save()
```

因为 update() 是在 SQL 级别上进行更新，因此，它不会在模型上调用任何 save() 方法，也不会发出 pre_save 或 post_save 信号

## 删

## delete()

对 QuerySet 中的所有行执行 SQL 删除查询，并返回删除的对象数量和每个对象类型的删除数量的字典。

```python
>>> b = Blog.objects.get(pk=1)

# Delete all the entries belonging to this Blog.
>>> Entry.objects.filter(blog=b).delete()
(4, {'weblog.Entry': 2, 'weblog.Entry_authors': 2})
```

> 默认情况下，Django 的 ForeignKey 模拟了 SQL 约束 ON DELETE CASCADE
{.is-info}

delete() 方法进行批量删除，会为所有被删除的对象（包括级联删除）发出 pre_delete 和 post_delete 信号。

Django 需要将对象获取到内存中来发送信号和处理级联。但是，如果没有级联和信号，那么 Django 可能会采取**快速路径**删除对象，而不需要将其获取到内存中。对于大面积的删除，这可以使内存使用量大大降低。也可以减少执行查询的数量。

设置为 on_delete=DO_NOTHING 的外键不会阻止在删除时采取快速路径。







