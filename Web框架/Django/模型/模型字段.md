---
title: 模型字段
description: 
published: true
date: 2021-03-19T06:19:22.658Z
tags: django
editor: markdown
dateCreated: 2021-02-24T02:43:11.974Z
---

# 字段

- 模型：相当于 Python 的类，映射一张数据库表。继承自 `django.db.models.Model`
- 属性：相当于一个数据库的字段，映射为一个数据库列。`Field` 类的实例

例如：

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

采用 MySQL 8.0 对应数据库表结构如下：

```sql
CREATE TABLE `myapp_person` (
  `id` int NOT NULL AUTO_INCREMENT,
  `first_name` varchar(30) NOT NULL,
  `last_name` varchar(30) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```

# 字段类型

> [字段类型参考文档](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#model-field-types)
{.is-success}

模型中每一个字段都是某个 Field 类的实例，Django 利用这些字段类来实现以下功能：

- 字段类型用以指定数据库数据类型
- 在渲染表单字段时默认使用的 HTML 视图 (如： `<input type="text">, <select>`)。
- 基本的有效性验证功能，用于 Django 后台和自动生成的表单。

```python
class ALLFieldType(models.Model):
    # AutoFiled
    id = models.AutoField(primary_key=True)
    # smallAutoField = models.SmallAutoField()  # Django 3.0
    # bigAutoField = models.BigAutoField()

    # IntegerField
    integerField = models.IntegerField()
    smallIntegerField = models.SmallIntegerField()
    bigIntegerField = models.BigIntegerField()

    # PositiveIntegerField
    positiveIntegerField = models.PositiveIntegerField()
    positiveSmallIntegerField = models.PositiveSmallIntegerField()
    positiveBigIntegerField = models.PositiveBigIntegerField()

    # datetime / time
    timeField = models.TimeField()
    dateTime = models.DateTimeField()
    dateField = models.DateField()
    durationField = models.DurationField()

    # char / text
    charField = models.CharField(max_length=20)
    textField = models.TextField()

    # file
    fileField = models.FileField()
    filePathField = models.FilePathField()
    imageField = models.ImageField()

    # float
    decimalField = models.DecimalField(max_digits=5, decimal_places=3)
    floatField = models.FloatField()

    # boolean
    # nullBooleanField = models.NullBooleanField() # 3.1 版后已移除
    booleanField = models.BooleanField()

    #
    binaryField = models.BinaryField()
    emailField = models.EmailField()
    urlField = models.URLField()
    uuidField = models.UUIDField()
    genericIpAddressField = models.GenericIPAddressField()
    jsonField = models.JSONField()
    slugField = models.SlugField()

    # 关系字段:
    # ForeignKey / ManyToManyField / OneToOneField
```


```sql
create table myapp_allfieldtype
(
    id                        int auto_increment primary key,
    integerField              int               not null,
    smallIntegerField         smallint          not null,
    bigIntegerField           bigint            not null,
    positiveIntegerField      int unsigned      not null,
    positiveSmallIntegerField smallint unsigned not null,
    positiveBigIntegerField   bigint unsigned   not null,
    timeField                 time(6)           not null,
    dateTime                  datetime(6)       not null,
    dateField                 date              not null,
    durationField             bigint            not null,
    charField                 varchar(20)       not null,
    textField                 longtext          not null,
    fileField                 varchar(100)      not null,
    filePathField             varchar(100)      not null,
    imageField                varchar(100)      not null,
    decimalField              decimal(5, 3)     not null,
    floatField                double            not null,
    booleanField              tinyint(1)        not null,
    binaryField               longblob          not null,
    emailField                varchar(254)      not null,
    urlField                  varchar(200)      not null,
    uuidField                 char(32)          not null,
    genericIpAddressField     char(39)          not null,
    jsonField                 json              not null,
    slugField                 varchar(50)       not null
);
```

## AutoField

> 一个模型类中，只能有一个 AutoField 类型的字段
{.is-warning}


| 字段类型         | 数据库类型                | 描述                                    |
| ---------------- | ------------------------- | --------------------------------------- |
| `AutoField`      | `int auto_increment`      | 32 位整数自增，默认自增主键                            |
| `SmallAutoField` | `smallint auto_increment` | 16 位整数自增，1 到 32767 的值                         |
| `BigAutoField`   | `bigint auto_increment`   | 64 位整数自增，1 到 9223372036854775807 |


## IntegerField

| 字段类型            | 数据库类型  | 描述                                                         |
| ------------------- | ----------- | ------------------------------------------------------------ |
| `SmallIntegerField` | `smallint ` | 16 位整数，-32768 到 32767的值                               |
| `IntegerField`      | `int`       | 32 位整数。-2147483648 到 2147483647 的值                  |
| `BigIntegerField`   | `bigint`    | 64 位整数。-9223372036854775808 到 9223372036854775807 的数字 |

- `IntegerField`：当 localize 为 False 时是 `NumberInput`。否则，该字段的默认表单部件是 `TextInput`。
- `BigIntegerField`：该字段的默认表单部件是一个 `NumberInput`。


## PositiveIntegerField

| 字段类型                    | 数据库类型          | 描述                         |
| --------------------------- | ------------------- | ---------------------------- |
| `PositiveSmallIntegerField` | `int unsigned `     | 0 到 32767 的值              |
| `PositiveIntegerField`      | `smallint unsigned` | 0 到 2147483647 的值      |
| `PositiveBigIntegerField`   | `bigint unsigned`   | 0 到 223372036854775807 的值 |


## Time

| 字段类型        | 数据库类型    | 描述                                                         |
| --------------- | ------------- | ------------------------------------------------------------ |
| `TimeField`     | `time(6) `    | 时间，在 Python 中用 `datetime.time` 实例表示<br>默认的表单部件是一个`TimeInput` |
| `DateTimeField` | `datetime(6)` | 日期和时间，在 Python 中用一个 `datetime.datetime` 实例表示<br>默认表单部件是一个单独的 `DateTimeInput` |
| `DateField`     | `date`        | 日期，在 Python 中用一个 `datetime.date` 实例表示            |
| `DurationField` | `bigint`      | 用于存储时间段的字段，在 Python 中用 `timedelta`建模         |


## Char

| 字段类型                | 数据库类型     | 描述                                                |
| ----------------------- | -------------- | --------------------------------------------------- |
| `CharField(max_length)` | `varchar(20) ` | 字符串字段。默认表单部件是一个`TextInput`           |
| `TextField`             | `longtext`     | 大的文本字段。该字段的默认表单部件是一个 `Textarea` |


## File

| 字段类型        | 数据库类型      | 描述                                                         |
| --------------- | --------------- | ------------------------------------------------------------ |
| `FileField`     | `varchar(100) ` | 文件上传字段                                                 |
| `FilePathField` | `varchar(100)`  | 一个`CharField`，其选择仅限于文件系统中某个目录下的文件名    |
| `ImageField`    | `varchar(100)`  | 继承`FileField`的所有属性和方法，但也验证上传的对象是有效的图像 |

## Float

当 `localize` 为 False 时是 `NumberInput` 否则，该字段的默认表单部件是 `TextInput`。

| 字段类型                                     | 数据库类型      | 描述                                                         |
| -------------------------------------------- | --------------- | ------------------------------------------------------------ |
| `DecimalField(max_digits=, decimal_places=)` | `decimal(x,y) ` | 固定精度的十进制数                                           |
| `FloatField`                                 | `double`        | 在 Python 中用一个 `float` 实例表示的浮点数 |

## 其他


| 字段类型                | 数据库类型     | 描述                                                         |
| ----------------------- | -------------- | ------------------------------------------------------------ |
| `BooleanField`          | `tinyint(1)`   | `true / false` 字段，该字段的默认表单部件是 `CheckboxInput`  |
| `BinaryField`           | `longblob`     | 用于存储原始二进制数据的字段                                 |
| `EmailField`            | `varchar(254)` | 是否为有效的电子邮件地址                                     |
| `URLField`              | `varchar(200)` | 该字段的默认表单部件是一个`URLInput`                         |
| `UUIDField`             | `char(32)`     | 存储通用唯一标识符的字段。使用 Python 的 [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID) 类 |
| `GenericIPAddressField` | `char(39)`     | IPv4 或 IPv6 地址                                            |
| `JSONField(Django 3.1)` | `json`         | 存储 JSON 编码数据的字段                                     |
| `SlugField`             | `varchar(50)`  | 简短的标签，只包含字母、数字、下划线或连字符                 |


# 字段选项

> [字段选项参考文档](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#common-model-field-options)
{.is-success}

| 字段选项          | 描述                                                         |
 | ----------------- | ------------------------------------------------------------ |
 | `null`            | Django 将在数据库中存储空值为 `NULL`。默认为 `False`。对于　CharField 和 TextField　默认为空字符串 |
 | `blank`           | `blank=True`，表单验证将允许输入一个空值。默认为 `False` 。  |
 | `choices`         | 二元组，第一个值会储存在数据库中，而第二个值将只会用于在表单中显示。使用 `get_FOO_display()` 方法可以获取第二个值                               |
 | `db_column`       | 要使用的数据库列名。如果没有给出列名，Django 将使用字段名。  |
 | `db_index`        | 为该字段创建数据库索引。                                     |
 | `db_tablespace`   | 如果这个字段有索引，那么要为这个字段的索引使用的 [数据库表空间](https://docs.djangoproject.com/zh-hans/3.1/topics/db/tablespaces/) 的名称。默认是项目的 [`DEFAULT_INDEX_TABLESPACE`](https://docs.djangoproject.com/zh-hans/3.1/ref/settings/#std:setting-DEFAULT_INDEX_TABLESPACE) 设置（如果有设置），或者是模型的 [`db_tablespace`](https://docs.djangoproject.com/zh-hans/3.1/ref/models/options/#django.db.models.Options.db_tablespace) （如果有）。如果后端不支持索引的表空间，则忽略此选项。 |
 | `default`         | 默认值。可以是一个值或者是个可调用的对象。如果是个可调用对象，每次实例化模型时都会调用该对象。 |
 | `editable`        | 如果是 `False`，该字段将不会在管理或任何其他 [`ModelForm`](https://docs.djangoproject.com/zh-hans/3.1/topics/forms/modelforms/#django.forms.ModelForm) 中显示。在 [模型验证](https://docs.djangoproject.com/zh-hans/3.1/ref/models/instances/#validating-objects) 中也会跳过。默认为 `True`。 |
 | `error_messages`  | 覆盖该字段引发的默认消息。传入一个与你想覆盖的错误信息相匹配的键值的字典。 |
 | `help_text`       | 额外的“帮助”文本，随表单控件一同显示。即便你的字段未用于表单，它对于生成文档也是很有用的。 |
 | `primary_key`     | 如果设置为 `True` ，将该字段设置为该模型的主键。则 Django 不会自动在表（模型）中添加 id 列。每个模型都需要拥有一个设置了 `primary_key=True` 的字段（无论是显式的设置还是 Django 自动设置）。             |
 | `unique`          | 如果设置为 `True`，这个字段必须在整个表中保持值唯一。        |
 | `unique_for_date` | 将其设置为 [`DateField`](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.DateField) 或 [`DateTimeField`](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.DateTimeField) 的名称，要求该字段的日期字段值是唯一的。 |
 | `verbose_name`    | 字段的一个人类可读名称，如果没有给定详细名称，Django 会使用字段的属性名自动创建，并将下划线转换为空格 |
 | `validators`      | 要为该字段运行的验证器列表。                                 |

# ForeignKey

ForeignKey 表示多对一的关系。需要两个位置参数：模型相关的类和 on_delete 选项。

例如下面处于同一个 `app01` 应用的 User 模型和 Group 模型，表示多个 User 存在一个 Group。

```python
class User(models.Model):
    name = models.CharField(max_length=20)
    user = models.ForeignKey('Group', on_delete=models.CASCADE)

class Group(models.Model):
    title = models.CharField(max_length=20)
```

上述的模型对应 MySQL 的 SQL 建表语句如下：

```sql
CREATE TABLE `app01_user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `group_id` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `app01_user_group_id_38b03a6e_fk_app01_group_id` (`group_id`),
  CONSTRAINT `app01_user_group_id_38b03a6e_fk_app01_group_id` FOREIGN KEY (`group_id`) REFERENCES `app01_group` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

CREATE TABLE `app01_group` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```

> 默认情况下，`ForeignKey` 命名为 `字段名_id`，且会自动创建一个数据库索引。你可以通过设置 `db_index` 为 False 来禁用它。
{.is-info}


如果上面的 Group 模型是在另一个叫做 `app02` 的应用程序中定义的，你需要使用 `app02.Group` 指明关联模型类

```sql
class User(models.Model):
    name = models.CharField(max_length=20)
    group = models.ForeignKey('app02.Group', on_delete=models.CASCADE)
```

这种被称为**懒惰关系**的引用，在解决两个应用程序之间的循环导入依赖关系时很有用。

## [on_delete](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#arguments)

该参数用于控制由 ForeignKey 引用的对象被删除时，将模拟对应 SQL 约束的行为。

其可能的取值为：

| 值                                                           | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `CASCADE`                                                    | 级联删除。Django 模拟了 SQL 约束 `ON DELETE CASCADE` 的行为，也删除了包含 ForeignKey 的对象。 |
| `PROTECT`                                                    | 通过引发 `ProtectedError`，即 `django.db.IntegrityError` 的子类，防止删除被引用对象。 |
| [`RESTRICT`](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.RESTRICT) | Django 3.1 支持                                              |
| `SET_NULL`                                                   | 设置 ForeignKey 为空，前提是 `null = True`。                 |
| `SET_DEFAULT`                                                | 将 ForeignKey 设置为默认值，前提是设置 `Default` 参数        |
| `SET()`                                                      | 将 ForeignKey 设置为传递给 `SET()` 的值，如果传递了一个可调用的值，则为调用它的结果 |
| `DO_NOTHING`                                                 | 不采取任何行动。如果你的数据库后端强制执行引用完整性，这将导致一个 `IntegrityError` 除非你手动添加一个 `SQL ON DELETE` 约束条件到数据库字段。 |

## [related_name](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.ForeignKey.related_name)

```python
class User(models.Model):
    name = models.CharField(max_length=20)
    group = models.ForeignKey('Group', on_delete=models.CASCADE)

class Group(models.Model):
    title = models.CharField(max_length=20)
```

```python
>>> User.objects.all()
<QuerySet [<User: Jack>, <User: Tom>, <User: Mike>]>
>>> Group.objects.all()
<QuerySet [<Group: 技术>, <Group: 产品>]>
```

如果一个 User 想要访问其所在的 Group，那么可以通过 ForeignKey group 来进行访问。

```python
>>> user = User.objects.get(id=1)
>>> user.name
'Jack'
>>> user.group
<Group: 技术>
```

但是如果一个 Group 想要访问其所有的 User 怎么办？

1. 可以通过下面的方法：`模型名字小写_set`

```python
>>> group = Group.objects.get(id=1)
>>> group.title
'技术'
>>> group.user_set.all()
<QuerySet [<User: Jack>, <User: Tom>]>
```

2. 给 ForeignKey 增加 related_name 属性，相当于替代 user_set

```python
class User(models.Model):
    name = models.CharField(max_length=20)
    group = models.ForeignKey('Group', on_delete=models.CASCADE, related_name='users')

>>> group = Group.objects.get(id=1)
>>> group.title
'技术'
>>> group.users.all() # 使用 related_name
<QuerySet [<User: Jack>, <User: Tom>]>
```

> 如果你不希望创建一个反向关系，可以将 `related_name` 设置为 `'+'` 或者以 `'+'` 结束
{.is-warning}


## [related_query_name](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.ForeignKey.related_query_name)

关联模型查找数据时，可以通过指定相关联的模型满足什么属性，例如：查找 Group 中 User 名称为 Jack 的 group

```python
# 规则：ForeignKey 关联字段__关联模型字段
>>> group = Group.objects.filter(user__name='Jack')
>>> group
<QuerySet [<Group: 技术>]>
```

如果设置了 related_name 那么上例代码将改成如下：

```python
# 使用 related_name = 'user'
>>> group = Group.objects.filter(users__name='Jack')
>>> group
<QuerySet [<Group: 技术>]>
```

而 related_query_name 就可以将查询的反转名字修改成其他的名字，比如修改为 user2：

```python
# 使用 related_query_name = 'user2'
>>> group = Group.objects.filter(user2__name='Jack')
>>> group
<QuerySet [<Group: 技术>]>
```

> 其他更多属性，请参考[官方文档](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.ForeignKey.to_field)
{.is-info}

# ManyToManyField

多对多的关系。需要一个位置参数：模型相关的类。但是其背后 Django 会创建了一个中间连接表来表示多对多的关系。

默认情况下，这个表名是使用多对多字段的名称和包含它的模型的表名生成的，比如下面的：`app01_article_publications`。由于有些数据库不支持超过一定长度的表名，这些表名将被自动截断，并使用唯一性哈希，例如 author_books_9cdf。

不过可以使用 `db_table` 选项自定义中间表的名称。

```python
class Publication(models.Model):
    title = models.CharField(max_length=30)

class Article(models.Model):
    headline = models.CharField(max_length=100)
    publications = models.ManyToManyField(Publication)
```

```sql
CREATE TABLE `app01_article` (
  `id` int NOT NULL AUTO_INCREMENT,
  `headline` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

CREATE TABLE `app01_publication` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(30) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

# 中间表
CREATE TABLE `app01_article_publications` (
  `id` int NOT NULL AUTO_INCREMENT,
  `article_id` int NOT NULL,
  `publication_id` int NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `app01_article_publicatio_article_id_publication_i_7a20a9be_uniq` (`article_id`,`publication_id`),
  KEY `app01_article_public_publication_id_40665d36_fk_app01_pub` (`publication_id`),
  CONSTRAINT `app01_article_public_article_id_b2ab7be5_fk_app01_art` FOREIGN KEY (`article_id`) REFERENCES `app01_article` (`id`),
  CONSTRAINT `app01_article_public_publication_id_40665d36_fk_app01_pub` FOREIGN KEY (`publication_id`) REFERENCES `app01_publication` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```

ManyToManyField 所涉及的一些参数用法与 ForeignKey 相同。除了个别特有的参数。

> 注意：使用多对多关系由于无法确定反向查询的名称，两个模型中至少一个设置 `related_name`。如果不希望 Django 不创建反向关系，将 `related_name` 设置为 `'+'`。
{.is-warning}


## [through](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.ManyToManyField.through)

默认情况下，Django 会自动生成一个中间表来管理多对多关系，使用该参数可以自定义中间表。

通常目的是为了给中间表添加额外字段而使用。

```python
class Publication(models.Model):
    title = models.CharField(max_length=30)


class Article(models.Model):
    headline = models.CharField(max_length=100)
    publications = models.ManyToManyField(Publication)


class ArticlePublication(models.Model):
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    publication = models.ForeignKey(Publication, on_delete=models.CASCADE)
    # 添加额外字段
    pub_date = models.DateTimeField(default=datetime.now)

    class Meta:
        # 自定义中间表名
        db_table = "article_publication_relationship"
```

## [through_fields](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.ManyToManyField.through_fields)

只有当指定了一个自定义的中间模型时才会使用，`through_fields` 接受一个二元元组 `('field1', 'field2')`，其中 field1 是定义在 ManyToManyField 上的模型（本例中为 article ）的外键名称，field2 是目标模型（本例中为 person ）的外键名称。

```python
class Publication(models.Model):
    title = models.CharField(max_length=30)

    def __str__(self):
        return self.title


class Article(models.Model):
    headline = models.CharField(max_length=100)
    publications = models.ManyToManyField(Publication, through='ArticlePublication',
                                          through_fields=('article', 'publication'))

class ArticlePublication(models.Model):
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    publication = models.ForeignKey(Publication, on_delete=models.CASCADE)
    # 添加额外字段
    pub_date = models.DateTimeField(default=datetime.now)

    class Meta:
        # 自定义中间表名
        db_table = "article_publication_relationship"
```

> 其他更多属性，请参考[官方文档](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.ManyToManyField.db_table)
{.is-info}

# OneToOneField

一对一的关系。概念上，这类似于 ForeignKey 与 unique=True，但关系的“反向”将直接返回一个单一对象。

最有用的是作为某种方式**扩展**另一个模型的主键。需要一个位置参数：模型将与之相关的类

```python
from django.conf import settings
from django.db import models

class MySpecialUser(models.Model):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
    )
    supervisor = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='supervisor_of',
    )
```

```python
>>> from django.contrib.auth.models import User
>>> user = User.objects.get(pk=1)
>>> hasattr(user, 'myspecialuser')
True
>>> hasattr(user, 'supervisor_of')
True
```

当访问反向关系时，如果相关表中的条目不存在，就会引发一个 `RelatedObjectDoesNotExist` 异常。这是目标模型的 `Model.DoesNotExist` 异常的一个子类。

OneToOneField 接受 ForeignKey 接受的所有额外参数，外加一个额外参数：[parent_link](https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.OneToOneField.parent_link)
