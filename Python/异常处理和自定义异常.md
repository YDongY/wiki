---
title: 异常处理和自定义异常
description: 
published: true
date: 2021-03-06T02:48:38.001Z
tags: python
editor: markdown
dateCreated: 2021-03-06T02:48:08.520Z
---

# 处理异常

```python
>>> while True:
...     try:
...         x = int(input("Please enter a number: "))
...         break
...     except ValueError:
...         print("Oops!  That was no valid number.  Try again...")
...
```

工作原理：

1. 首先，执行 `try` 子句。
2. 如果没有异常发生，则跳过 `except` 子句并完成`try`语句的执行。
3. 如果在执行 `try` 子句时发生了异常，则跳过该子句中剩下的部分。然后，如果异常的类型和 `except`关键字后面的异常匹配，则执行 `except` 子句
4. 如果发生的异常和 `except` 子句中指定的异常不匹配，则将其传递到外部的`try`语句中

## try-except

一个 `try`语句可能有多个 `except` 子句，以指定不同异常的处理程序

```python
... except (RuntimeError, TypeError, NameError):
...     pass
```

也可以在 `except` 子句可以在异常名称后面指定一个变量。这个变量和一个异常实例绑定，它的参数存储在 `instance.args` 中

```python
>>> try:
...     raise Exception('spam', 'eggs')
... except Exception as inst:
...     print(type(inst))    # the exception instance
...     print(inst.args)     # arguments stored in .args
...     print(inst)          # __str__ allows args to be printed directly,
...                          # but may be overridden in exception subclasses
...     x, y = inst.args     # unpack args
...     print('x =', x)
...     print('y =', y)
...
<class 'Exception'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs
```

## else

其次，`try...except`语句有一个可选的 else 子句，在使用时必须放在所有的 except 子句后面

```python
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except OSError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()
```

## finally

- 如果存在`finally`子句，则 `finally` 子句将作为`try`语句结束前的最后一项任务被执行。 `finally` 子句不论 `try` 语句是否产生了异常都会被执行

- 如果在执行 `try` 语句时遇到一个`break`, `continue`或 `return`语句，则 `finally` 子句将在执行 `break`, `continue` 或 `return` 语句之前被执行。

- 如果 `finally` 子句中包含一个 `return` 语句，则返回值将来自 `finally` 子句的某个 `return` 语句的返回值，而非来自 `try` 子句的 `return` 语句的返回值。

```python
def f():
    try:
        print("try")
        return "try" 
    finally:
        print("finally")
        return "finally"
>>> try
>>> finally
>>> res: finally
```

> 在实际应用程序中，`finally`子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是否成功使用资源。
{.is-info}


# 抛出异常

`raise` 语句支持强制触发指定的异常。唯一的参数就是要触发的异常。这个参数必须是异常实例或异常类（派生自 [`Exception`](https://docs.python.org/zh-cn/3/library/exceptions.html#Exception) 的类）例如：

```python
>>> raise NameError('HiThere')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: HiThere
```


# 自定义异常

异常通常应该直接或间接地从`Exception`类派生。

```python
class Error(Exception):
    """Base class for exceptions in this module."""
    pass

class InputError(Error):
    """Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    """

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message
```

