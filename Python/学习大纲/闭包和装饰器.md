---
title: 20. 闭包和装饰器
description: 
published: true
date: 2021-03-13T05:13:26.664Z
tags: 
editor: markdown
dateCreated: 2021-03-13T05:13:03.333Z
---

# 闭包

在一个函数内部定义了一个函数，并且内部函数里使用了外部函数的临时变量，同时外层函数的返回值是内部函数的引用。这样就构成了一个闭包。

```python
def outer():
    msg = "I'm outer"

    def inner():
        print(msg)
    return inner

# 这里获得的就是一个闭包
inner = outer() # 返回内部函数的引用
# 输出 I'm outer
inner() # 调用内部函数
```

msg 是一个局部变量，在 outer 函数执行之后应该就不会存在了。但是嵌套函数引用了这个变量，如果我们想要修改外层函数定义的变量是没法直接修改，就如同在函数内部需要全局变量一样也是拒绝的，不过可以通过 nonlocal 关键字声明变量，类似于 global 

```python
msg = "I'm global" # 全局变量

def outer():
    msg = "I'm outer" # 嵌套函数变量

    def inner():
        nonlocal msg
        msg = "I'm inner" # 局部变量
        print(msg)

    return inner

inner = outer()
# 输出 I'm inner
inner()
print(msg)  # I'm global
```

# 装饰器

装饰器就是基于闭包实现的，只不过是用了特殊的语法糖。下面是一个装饰器简单的实现：


```python
def outer(func):
    def inner():
        print("-----权限1----")
        print("-----权限2----")
        func()

    return inner

@outer  # 等价于func = outer(func)
def func():
    print("----func----")

func()

>>>-----权限1----
>>>-----权限2----
>>>----func----
```

装饰器有三处不同：

1. 在函数头上定义了一个 @outer
2. 在 outer 函数传入了一个参数 func
3. 在 inner 的最后执行了 func()

代码的执行流程：

1. 由于装饰器的作用，把我们当前的函数进行了装饰，也就演变成了func = outer(func)，
2. 把我们的函数名传给了 outer 函数，返回了 inner，此时func = inner，装饰完成。
3. 当我们调用 func() 的时候，实际调用的 inner()，然后依次打印 --权限1--- 、 ---权限2---，接着执行 func()，此时的 func 就是最开始被装饰的函数，最后打印 ----func--- ，代码执行结束。


小结

- 装饰器本质上就是一个闭包函数，它可以对已有函数进行额外的功能扩展。
- 装饰器的语法格式:

```
# 装饰器
# def decorator(fn): # fn:被装饰的目标函数.
#     def inner():
#         '''执行函数之前'''
#         fn() # 执行被装饰的目标函数
#         '''执行函数之后'''
#     return inner
```

- 装饰器的语法糖用法: @装饰器名称，同样可以完成对已有函数的装饰操作。

## 装饰器的小问题

我们装饰的函数已经实现了动态添加功能的目的，但是当我们使用 `func.__name__` 的时候结果是 inner 却不是 func，同理如果函数中定义了注释文档，也会被 inner 替代。而我们不希望，就可以利用 `functools.wraps` 来解决。

```python
from functools import wraps

def outer(func):
    @wraps(func)
    def inner():
        print("-----权限1----")
        print("-----权限2----")
        func()

    return inner

@outer  # 等价于func = outer(func)
def func():
    """我是 func"""
    print("----func----")

func()

print(func.__name__) # func
print(func.__doc__) # 我是 func
```

# 通用装饰器

## 有返回值

```python
from functools import wraps

def outer(func):
    @wraps(func)
    def inner(*args, **kwargs):
        return func(*args, **kwargs)

    return inner

@outer
def func(*args, **kwargs):
    return "ok"

func()
```

## 无返回值

```python
from functools import wraps

def outer(func):
    @wraps(func)
    def inner(*args, **kwargs):
        func(*args, **kwargs)

    return inner

@outer
def func(*args, **kwargs):
    pass

func()
```

# 带有参数的装饰器

当我们想要给装饰器传递参数的时候，由于两层嵌套的闭包，外层函数需要接受被装饰函数的引用，所以需要在原有的基础上在嵌套一层函数又来接收参数，下面有一个简单的例子：

```python
def set_level(level_num):
    def set_func(func):
        def call_func(*args, **kwargs):
            if level_num == 1:
                print("---权限级别1，验证---")
            elif level_num == 2:
                print("---权限级别2，验证---")
            return func()

        return call_func

    return set_func

@set_level(1) # 给装饰器传入参数1
def test1():
    print("-----test1----")
    return "ok"
test1()
```

此时的代码并不是一次直接把 test1函数进行装饰，而是执行以下步骤：

1. 调用 set_level 将参数做实参传递相当于调用 set_level(1) 返回值 set_func
2. 用上一步的返回值当作装饰器对 test1 函数进行装饰 test1 = set_func(test1)

# 类装饰器

首先看下面的一个例子：

```python
class Outer(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        return self.func()

@Outer  # 相当于:func = Outer(func),相当于创建一个对象，而func()，会调用__call__
def func():
    return "ok"

func()  # 相当于 对象名() ，直接调用__call__方法
```

正常通过函数实现的装饰器，在最终的结果执行的时候，实际优先调用的是闭包中的内层函数。

如果我们通过类实现，在开始装饰的时候实际是返回了一个类对象，如同：`func = Outer(func)` 返回的是 Outer 类的对象。当我们最终调用 func 函数的时候，实际是 `对象()` 的形式，其内部执行的是 `__call__` 方法，即我们通过类实现的装饰器只需要把处理逻辑放在 `__call__` 方法即可。

# 多个装饰器

Python 也支持多个装饰器，比如写成下面这样的形式：

```python
@decorator1
@decorator2
@decorator3
def func():
    ...
```


它的执行顺序从里到外，所以上面的语句也等效于下面这行代码：

```python
decorator1(decorator2(decorator3(func)))
```

一个例子写成下面这样：

```python
import functools
 
def my_decorator1(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('execute decorator1')
        func(*args, **kwargs)
    return wrapper
 
 
def my_decorator2(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('execute decorator2')
        func(*args, **kwargs)
    return wrapper
 
 
@my_decorator1
@my_decorator2
def greet(message):
    print(message)
 
 
greet('hello world')
 
# 输出
execute decorator1
execute decorator2
hello world
```

# 使用场景

## 授权

装饰器能有助于检查某个人是否被授权去使用一个 web 应用的端点 (endpoint)。 它们被大量使用于 Flask 和 Django web 框架中。 这里是一个例子来使用基于装饰器的授权：

```python
def login_required(func):
    @wraps(func)
    def inner(*args, **kwargs):
        user_id = session.get(constants.CMS_USER_ID) # 获取用户信息
        if user_id:
            return func(*args, **kwargs) # 存在信息，执行是视图函数
        else:
            return redirect(url_for('login'), code=302) # 不存在信息，执行跳转登录
    return inner

@login_required
def p_center():
    return "personal center page"
```

## 日志

假设我们现在有一个需求场景是需要对某些函数的执行记录日志，并且希望通过邮件发送的形式通知我们，同样我们也可以使用装饰器实现。

```python
import time
from functools import wraps

def logger(path):
    fp = open(path, 'a+')

    def outer(f):
        @wraps(f)
        def inner(*args, **kwargs):
            ret = f()
            print(ret)
            fp.write("[{now}] [{name}] ===> {info}\n".format(now=time.ctime(), 
                        name=func.__name__, info=ret))
            fp.close()
            return ret
        return inner
    return outer

@logger("./log.log")
def func():
    return "ok"

func()
```

通过类装饰器实现：

```python
import time
from functools import wraps


class Logger(object):
    def __init__(self, path):
        self.path = path

    def __call__(self, f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            with open(self.path, 'a+') as fp:
                ret = f()
                fp.write("[{now}] [{name}] ===> {info}\n".format(now=time.ctime(), 
                                name=func.__name__, info=ret))
            self.notify()  # 通知
            return ret

        return wrapper

    def notify(self):
        print("=====>邮件通知......")

# 带有参数，所以__init__用来接受参数,__call__用来装饰，则__call__内部需要定义处理函数
# 不带参数，__init__用来接受被装饰函数的引用，__call__作为处理函数
@Logger("./log.log") 
def func():
    return "ok"

func()

>>>=====>邮件通知......
```

# 函数执行时间的统计

```python
import time

# 装饰器函数
def get_time(func):
    def inner():
        begin = time.time()
        func()
        end = time.time()
        print("函数执行花费%f" % (end-begin))
    return inner


@get_time
def func1():
    for i in range(100000):
        print(i)
```
