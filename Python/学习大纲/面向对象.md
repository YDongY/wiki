---
title: 12. 面向对象
description: 
published: true
date: 2021-03-15T04:18:50.364Z
tags: 
editor: markdown
dateCreated: 2021-03-12T16:00:04.409Z
---

# 类

> 在 Python 2 中，通过是否继承 object 来区分经典类和新式类，在 Python 3 中都是新式类
{.is-info}

- 经典类

不由任意内置类型派⽣出的类，称之为经典类

```python
class 类名:
	pass
```

- 新式类

```python
class 类名(object):
	pass
```

# 对象

- 创建对象

```python
class MyFirstClass:
    pass
a = MyFirstClass()
b = MyFirstClass()


>>> a.__class__()
<__main__.MyFirstClass object at 0x7f33034d9070>
>>> b.__class__()
<__main__.MyFirstClass object at 0x7f33035d4850>
```

- 类也是对象

```python
>>> c = MyFirstClass
>>> d = c()
>>> d.__class__()
<__main__.MyFirstClass object at 0x7f33035d45b0>
```

# 属性和方法

```python
class Human(object):
    # 静态字段
    live = True

    def __init__(self, name):
        # 普通字段
        self.name = name

man = Human('Adam')
woman = Human('Eve')

# 有 live 属性
Human.__dict__
# 有 name 属性
man.__dict__
```

- 实例可以使用普通字段也可以使用静态字段

```python
>>> man.name
'Adam'
>>> man.live = False # 创建实例属性，而不是修改类属性
>>> man.__dict__ # 普通字段有 live 变量
{'name': 'Adam', 'live': False}
```

> 注意：当实例对象调用未定义，且属性名与类熟悉相同时，属于添加实例属性，而不是修改类属性
{.is-warning}

- 类可以使用静态字段和添加静态字段

```python
>>> Human.live
True
>>> Human.newattr = 1
>>> dir(Human)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', 
'__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', 
'__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', 
'__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', 
'__str__', '__subclasshook__', '__weakref__', 'live', 'newattr']
>>> Human.__dict__
mappingproxy({'__module__': '__main__', 'live': True, '__init__': <function 
Human.__init__ at 0x7f33034bc3a0>, '__dict__': <attribute '__dict__' of 
'Human' objects>, '__weakref__': <attribute '__weakref__' of 'Human' 
objects>, '__doc__': None, 'newattr': 1})
```

> 类属性字段在内存中只保存一份，对象属性在每个对象都保存一份
{.is-info}


# 私有属性和方法

- 单下划线私有，属于约定上的私有

```python
class Person():
    # 私有属性
    _name = 'jack'
    
    # 私有⽅法
    def _func(self):
        pass
        
Person._name # jack
```

- 双下划线私有，本质是修改了变量或方法名称，格式为`_类名__属性名`

```python
class Person():
    # 私有属性
    __name = 'jack'
    
    # 私有⽅法
    def __func(self):
        pass
        
# AttributeError: type object 'Person' has no attribute '__name'
Person.__name
```

可以通过 `dir()` 函数查看类的所有属性：

```python
dir(Person)

['_Person__func',
 '_Person__name',
 '__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__']
```

# self

self 指的是调⽤该函数的对象

```python
# 1. 定义类
class Washer():
  def wash(self):
    print('我会洗⾐服')
    # <__main__.Washer object at 0x0000024BA2B34240>
    print(self)
  
# 2. 创建对象
haier1 = Washer()
# <__main__.Washer object at 0x0000018B7B224240>
print(haier1)

# haier1对象调⽤实例⽅法
haier1.wash()
```

> 注意：打印对象和 self 得到的结果是⼀致的，都是当前对象的内存中存储地址
{.is-warning}

# 魔法⽅法

在 Python 中， `__xx__()` 的函数叫做魔法⽅法，指的是具有特殊功能的函数


## `__init__()`

`__init__()` ⽅法的作⽤：初始化对象

```python
class Washer():
    # 定义初始化功能的函数
    def __init__(self):
    		# 添加实例属性
        self.width = 500
				self.height = 800
    def print_info(self)：
    		# 类⾥⾯调⽤实例属性
				print(f'洗⾐机的宽度是{self.width}, ⾼度是{self.height}')

haier1 = Washer()
haier1.print_info()
```

- `__init__()` ⽅法，在创建⼀个对象时默认被调⽤，不需要⼿动调⽤
- `__init__(self)` 中的 self 参数，不需要开发者传递， python 解释器会⾃动把当前的对象引⽤传递过去

## 带参数的 `__init__()`

```python
class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def print_info(self):
        print(f'洗⾐机的宽度是{self.width}')
        print(f'洗⾐机的⾼度是{self.height}')
        
haier1 = Washer(10, 20)
haier1.print_info()
haier2 = Washer(30, 40)
haier2.print_info()
```

## `__str__()`

当使⽤ print 输出对象的时候，默认打印对象的内存地址。如果类定义了 `__str__()` ⽅法，那么就会打印从在这个⽅法中 return 的数据


```python
class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def __str__(self):
    		return '这是海尔洗⾐机的说明书'
    
haier1 = Washer(10, 20)
# 这是海尔洗⾐机的说明书
print(haier1)
```

## `__del__()`

当删除对象时， python 解释器也会默认调⽤ `__del__()` ⽅法。

```python
class Washer():
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def __del__(self):
				print(f'{self}对象已经被删除')
        
haier1 = Washer(10, 20)
# <__main__.Washer object at 0x0000026118223278>对象已经被删除
del haier1
```



