---
title: 13. 继承
description: 
published: true
date: 2021-03-12T16:23:57.588Z
tags: 
editor: markdown
dateCreated: 2021-03-12T16:23:57.588Z
---

# 继承

Python ⾯向对象的继承指的是多个类之间的所属关系，即⼦类默认继承⽗类的所有属性和⽅法

```python
# ⽗类A
class A(object):
    def __init__(self):
        self.num = 1
        
    def info_print(self):
        print(self.num)

# ⼦类B
class B(A):
    pass

result = B()
result.info_print() # 1
```

> 在 Python 中，所有类默认继承 object 类，object 类是顶级类或基类；其他⼦类叫做派⽣类
{.is-info}

# 单继承

```python
# 1. 师⽗类
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果⼦配⽅]'
    def make_cake(self):
        print(f'运⽤{self.kongfu}制作煎饼果⼦')

# 2. 徒弟类
class Prentice(Master):
    pass

# 3. 创建对象daqiu
daqiu = Prentice()

# 4. 对象访问实例属性
print(daqiu.kongfu) # [古法煎饼果⼦配⽅]

# 5. 对象调⽤实例⽅法
daqiu.make_cake() # 运⽤[古法煎饼果⼦配⽅]制作煎饼果⼦
```


# 多继承

所谓多继承意思就是⼀个类同时继承了多个⽗类

```python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果⼦配⽅]'

    def make_cake(self):
        print(f'运⽤{self.kongfu}制作煎饼果⼦')

# 创建学校类
class School(object):
    def __init__(self):
        self.kongfu = '[道法煎饼果⼦配⽅]'
        
    def make_cake(self):
        print(f'运⽤{self.kongfu}制作煎饼果⼦')

class Prentice(School, Master):
    pass

daqiu = Prentice()
print(daqiu.kongfu) # [道法煎饼果⼦配⽅]
daqiu.make_cake() # 运⽤[道法煎饼果⼦配⽅]制作煎饼果⼦
```

# ⼦类重写⽗类同名⽅法和属性

```python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果⼦配⽅]'

    def make_cake(self):
        print(f'运⽤{self.kongfu}制作煎饼果⼦')

# 创建学校类
class School(object):
    def __init__(self):
        self.kongfu = '[道法煎饼果⼦配⽅]'
        
    def make_cake(self):
        print(f'运⽤{self.kongfu}制作煎饼果⼦')

class Prentice(School, Master):
    def __init__(self):
        self.kongfu = '[独创煎饼果⼦配⽅]'
    
    def make_cake(self):
        print(f'运⽤{self.kongfu}制作煎饼果⼦')

daqiu = Prentice()
print(daqiu.kongfu) # [独创煎饼果⼦配⽅]
daqiu.make_cake() # 运⽤[独创煎饼果⼦配⽅]制作煎饼果⼦
```

> ⼦类和⽗类具有同名属性和⽅法，默认使⽤⼦类的同名属性和⽅法

# ⼦类调⽤⽗类的同名⽅法和属性


```python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果⼦配⽅]'

    def make_cake(self):
        print(f'运⽤{self.kongfu}制作煎饼果⼦')

# 创建学校类
class School(object):
    def __init__(self):
        self.kongfu = '[道法煎饼果⼦配⽅]'
        
    def make_cake(self):
        print(f'运⽤{self.kongfu}制作煎饼果⼦')

class Prentice(School, Master):
    def __init__(self):
        self.kongfu = '[独创煎饼果⼦配⽅]'

    def make_cake(self):
        # 如果是先调⽤了⽗类的属性和⽅法，⽗类属性会覆盖⼦类属性，故在调⽤属性前，先调⽤⾃⼰⼦类的初始化
        self.__init__()

        print(f'运⽤{self.kongfu}制作煎饼果⼦')

    # 调⽤⽗类⽅法，但是为保证调⽤到的也是⽗类的属性，必须在调⽤⽅法前调⽤⽗类的初始化
    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)
        
    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)

daqiu = Prentice()
daqiu.make_cake() # 运⽤[独创煎饼果⼦配⽅]制作煎饼果⼦
daqiu.make_master_cake() # 运⽤[古法煎饼果⼦配⽅]制作煎饼果⼦
daqiu.make_school_cake() # 运⽤[道法煎饼果⼦配⽅]制作煎饼果⼦
daqiu.make_cake() # 运⽤[独创煎饼果⼦配⽅]制作煎饼果⼦
```

# 多重继承

```python
# 徒孙类
class Tusun(Prentice):
    pass
xiaoqiu = Tusun()
xiaoqiu.make_cake() # 运⽤[独创煎饼果⼦配⽅]制作煎饼果⼦
xiaoqiu.make_school_cake() # 运⽤[道法煎饼果⼦配⽅]制作煎饼果⼦
xiaoqiu.make_master_cake() # 运⽤[古法煎饼果⼦配⽅]制作煎饼果⼦
```

# super()调⽤⽗类⽅法


```python
class Master(object):
    def __init__(self):
        self.kongfu = '[古法煎饼果⼦配⽅]'

    def make_cake(self):
        print(f'运⽤{self.kongfu}制作煎饼果⼦')

# 创建学校类
class School(Master):
    def __init__(self):
        self.kongfu = '[道法煎饼果⼦配⽅]'
        
    def make_cake(self):
        # ⽅法2.1
        # super(School, self).__init__()
        # super(School, self).make_cake()
        
        # ⽅法2.2
        super().__init__()
        super().make_cake()

class Prentice(School):
    def __init__(self):
        self.kongfu = '[独创煎饼果⼦配⽅]'

    def make_cake(self):
        # 如果是先调⽤了⽗类的属性和⽅法，⽗类属性会覆盖⼦类属性，故在调⽤属性前，先调⽤⾃⼰⼦类的初始化
        self.__init__()

        print(f'运⽤{self.kongfu}制作煎饼果⼦')

    # 调⽤⽗类⽅法，但是为保证调⽤到的也是⽗类的属性，必须在调⽤⽅法前调⽤⽗类的初始化
    def make_master_cake(self):
        Master.__init__(self)
        Master.make_cake(self)
        
    def make_school_cake(self):
        School.__init__(self)
        School.make_cake(self)
        
    # ⼀次性调⽤⽗类的同名属性和⽅法
    def make_old_cake(self):
        # ⽅法⼀：代码冗余；⽗类类名如果变化，这⾥代码需要频繁修改
        # Master.__init__(self)
        # Master.make_cake(self)
        # School.__init__(self)
        # School.make_cake(self)
        
        # ⽅法⼆: super()
        # ⽅法2.1 super(当前类名, self).函数()
        # super(Prentice, self).__init__()
        # super(Prentice, self).make_cake()
        
        # ⽅法2.2 super().函数()
        super().__init__()
        super().make_cake()

daqiu = Prentice()
daqiu.make_old_cake() # 运⽤[古法煎饼果⼦配⽅]制作煎饼果⼦

# (__main__.Prentice, __main__.School, __main__.Master, object)
Prentice.__mro__
```

> 注意：使⽤ super() 可以⾃动查找⽗类。调⽤顺序遵循 `__mro__` 类属性的顺序。⽐较适合单继承使⽤。
{.is-warning}


# 私有权限

- 单下划线私有，属于约定上的私有

```python
class Person():
    # 私有属性
    _name = 'jack'
    
    # 私有⽅法
    def _func(self):
        pass
        
Person._name # jack
```

- 双下划线私有，本质是修改了变量或方法名称，格式为`_类名__属性名`

```python
class Person():
    # 私有属性
    __name = 'jack'
    
    # 私有⽅法
    def __func(self):
        pass
        
# AttributeError: type object 'Person' has no attribute '__name'
Person.__name
```

可以通过 `dir()` 函数查看类的所有属性：

```python
dir(Person)

['_Person__func',
 '_Person__name',
 '__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__']
```





