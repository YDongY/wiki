---
title: 导入模块
description: 
published: true
date: 2021-03-06T05:19:16.911Z
tags: python
editor: markdown
dateCreated: 2021-03-06T05:18:54.382Z
---

# 模块

模块就是一个与`.py` 结尾的 Python 源码文件。在模块内部，通过全局变量 `__name__` 可以获取模块名（即字符串）

模块包含可执行语句及函数定义。这些语句用于初始化模块，且仅在 import 语句**第一次**遇到模块名时执行

- 模块导入

```python
import module_name
from module_name import func_name, global_variable_name
from moduel_name import *
```

- 别名

```python
import module_name as mn
from module_name import func_name as fn
```

# `__name__ == '__main__'`作用

假设存在下面两个文件：

- `a.py`

```python
def f():
    print(f"{__name__}")

if __name__ == "__main__":
    f()
```

- `b.py`

```python
import a

a.f()
```

当把`a.py` 当做脚本使用时，`f()`函数输出`__main__`。当把`a.py`当做模块导入到`b.py`中执行，此时`f()`函数输出`a`。

也就说`a.py`当做脚本时运行，`__name__`就等于`__main__`。当`a.py`作为模块运行时，`__name__`就等于文件名`a`

而在文件中写入`if __name__ == "__main__"`表示，仅当文件作为脚本运行条件成立。


# 模块搜索路径

假设在`a.py` 导入`b.py`模块时：

1. 解释器首先查找名为`a`的内置模块
2. 如果没找到，解释器再从`sys.path`变量中的目录列表里查找 `b.py` 文件

`sys.path`初始化时包含以下位置：

```python
>>> import sys
>>> sys.path
['/home/ydongy/PycharmProjects/Python', # 运行脚本的目录在标准库路径之前
 '/usr/lib/python38.zip', 
 '/usr/lib/python3.8', 
 '/usr/lib/python3.8/lib-dynload', 
 '/home/ydongy/.local/lib/python3.8/site-packages',
 '/usr/local/lib/python3.8/dist-packages', 
 '/usr/lib/python3/dist-packages']
>>>
```

> 注意：符号连接目录并不会添加至模块搜索路径。初始化后，Python 程序可以更改 `sys.path`
{.is-info}

# pyc 文件

为了快速加载模块，Python 把模块的编译版缓存在 `__pycache__` 目录中，文件名为 `module.version.pyc`。例如：`foo.cpython-38.pyc`

![](https://s3.dualstack.us-east-2.amazonaws.com/pythondotorg-assets/media/dev/peps/pep-3147/pep-3147-1.png)

> 注意：从 `.pyc` 文件读取的程序不比从 `.py` 读取的执行速度快，`.pyc` 文件只是加载速度更快。
