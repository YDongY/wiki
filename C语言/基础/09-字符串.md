---
title: 09-字符串
description: 
published: true
date: 2021-02-21T14:39:04.938Z
tags: 
editor: undefined
dateCreated: 2021-02-21T14:39:01.974Z
---

# 字符串

{{< details title="要点回顾：" open=true >}}

1. C 语言没有字符串类型，本质是一个多个字符组成的字符数组
2. 字符串以 `\0` 作为结束标记
3. 使用字符串初始化，编译器自动在后面补 0

{{< /details >}}

## 字符串常量

- 用双引号引起的内容称为字符串常量，这样的字符串是不可以修改的
- 字符串输出时，利用 `%s` 进行格式化输出，当遇到 `\0` 输出结束

```c
// 字符串常量
void test01()
{
	// 字符串常量 用双引号，结束标志\0
	// 双引号代表告诉编译器是一个字符串，并且将字符串的首元素地址返回
	printf("%s\n", "hello world");
	printf("sizeof = %d\n", sizeof("hello world"));

	// %s 输出时  遇到\0 结束
	printf("%s\n", "hello\0world"); // hello
	printf("%s\n", "\0hello world"); // ""
}
```

## 字符串变量

- 将利用字符数组接受一个字符串常量，这个字符数组是可以修改的。
- 字符数组的内部使用一个空字符`'\0'`作为串的结尾，因此。存储字符串的物理存储单元数比括在双引号中的字符数多一个

```c
//字符串变量
void test02()
{
	// 等价于 char str[] = {'h','e','l','l','o','\0'}
	char str[] = "hello"; 
	printf("str = %s\n", str);
	printf("sizeof str = %d\n", sizeof(str));
}
```

## 字符数组和字符串

- C 语言中没有字符串这种数据类型，可以通过 char  数组来替代
- 数字 0 (和字符 ‘\0’ 等价)结尾的 char 数组就是一个字符串，但如果 char 数组没有以数字 0 结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的 char 数组

```c
#include <stdio.h>

int main()
{
	char c1[] = { 'c', ' ', 'p', 'r', 'o', 'g' }; //普通字符数组
	printf("c1 = %s\n", c1); //乱码，因为没有’\0’结束符

	//以‘\0’(‘\0’就是数字0)结尾的字符数组是字符串
	char c2[] = { 'c', ' ', 'p', 'r', 'o', 'g', '\0'}; 
	printf("c2 = %s\n", c2);

	//字符串处理以‘\0’(数字0)作为结束符，后面的'h', 'l', 'l', 'e', 'o'不会输出
	char c3[] = { 'c', ' ', 'p', 'r', 'o', 'g', '\0', 'h', 'l', 'l', 'e', 'o', '\0'};
	printf("c3 = %s\n", c3);

	return 0;
}
```

## 字符串初始化

```c
#include <stdio.h>

int main()
{
	// 不指定长度, 没有0结束符，有多少个元素就有多长
	char buf[] = { 'a', 'b', 'c' };
	printf("buf = %s\n", buf);	//乱码

	//指定长度，后面没有赋值的元素，自动补0
	char buf2[100] = { 'a', 'b', 'c'};
	printf("buf2 = %s\n", buf2);

	// 使用字符串初始化，编译器自动在后面补0，常用
	char buf3[] = "helloworld";
```

## 字符串函数

### gets()

`char *gets(char *s);`

- 从标准输入读入字符，并保存到 s 指定的内存空间，直到出现换行符或读到文件结尾为止。
- 成功：读入的字符串
- 失败：NULL

```c
void test_gets() {
    char str[50];
    printf("请输入一个字符串："); // a  b
    gets(str);
    printf("您输入的字符串是：%s", str); // a  b
}
```

`gets(str)` 与 `scanf("%s",str)` 的区别：

- gets(str) 允许输入的字符串含有空格
- scanf("%s",str) 不允许含有空格，输入带有空格的字符串会被截断

### fgets()

`char *fgets (char *s, int n, FILE *stream)`

从 stream 指定的文件内读入字符，保存到 s 所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了 n - 1个字符为止，最后会自动加上字符 '\0' 作为字符串结束。

- 参数：
    - s：字符串
    - n：指定最大读取字符串的长度（n - 1）
    - stream：文件指针，如果读键盘输入的字符串，固定写为 stdin
- 返回值：
    - 成功：成功读取的字符串
    - 读到文件尾或出错： NULL

```c
void test_fgets() {
    char str[50];
    printf("请输入一个字符串：");
    fgets(str, sizeof(str), stdin);
    printf("您输入的字符串是：%s", str);
}
```

### puts()

`int puts(const char *s);`

标准设备输出 s 字符串，在输出完成后自动输出一个 '\n'。

- 参数：
    - s：字符串首地址
- 返回值：
    - 成功：非负数
    - 失败：-1

```c
void test_puts(){
    char str[50] = "hello world";
    puts(str);
		printf("aaa");
		
		// hello world
		// aaa
}
```

### fputs()

`int fputs(const char * str, FILE * stream);`

将 str 所指定的字符串写入到 stream 指定的文件中，字符串结束符 '\0' 不写入文件。

- 参数：
    - str：字符串
    - stream：文件指针，如果把字符串输出到屏幕，固定写为 stdout
- 返回值：
    - 成功：0
    - 失败：-1

fputs() 是 puts() 的文件操作版本，但 fputs() 不会自动输出一个 '\n'。

```c
void test_fputs(){
    char str[50] = "hello world";
    fputs(str,stdout);
    printf("aaa");
		// hello worldaaa
}
```

### strlen()

`size_t strlen(const char *s);`

计算指定指定字符串 s 的长度，不包含字符串结束符 ‘\0’

- 参数：
    - s：字符串首地址
- 返回值：字符串s的长度，size_t 为 unsigned int 类型

```c
void test_strlen(){
    char str[50] = "hello world";
    printf("%lu \n",strlen(str)); // 11
}
```

### strcopy()

`char *strcpy(char *dest, const char *src);`

把 src 所指向的字符串复制到 dest 所指向的空间中，'\0' 也会拷贝过去

- 参数：
    - dest：目的字符串首地址
    - src：源字符首地址
- 返回值：
    - 成功：返回 dest 字符串的首地址
    - 失败：NULL

```c
void test_strcpy(){
    char str[50] = "hello world";
    char str2[] = "123456";
    strcpy(str2,str);
    printf("%s \n",str2); // hello world
}
```

### strncpy()

`char *strncpy(char *dest, const char *src, size_t n);`

把 src 指向字符串的前 n个字符复制到 dest 所指向的空间中，是否拷贝结束符看指定的长度是否包含'\0'。

- 参数：
    - dest：目的字符串首地址
    - src：源字符首地址
    - n：指定需要拷贝字符串个数
- 返回值：
    - 成功：返回dest字符串的首地址
    - 失败：NULL

```c
void test_strnpy(){
    char dest2[50] = {0};
    char src2[] = "hello world";
    strncpy(dest2, src2, 50); // n > src 拷贝 src ,n < src 拷贝 n 个字节，不添加 \0
    printf("%s \n", dest2);
}
```

### strcat()

`char *strcat(char *dest, const char *src);`

将 src 字符串连接到 dest 的尾部，‘\0’ 也会追加过去

- 参数：
    - dest：目的字符串首地址
    - src：源字符首地址
- 返回值：
    - 成功：返回dest字符串的首地址
    - 失败：NULL

```c
void test_strcat(){

	char dest3[10] = "dest";
	char src3[] = "src";
	strcat(dest3, src3);
	printf("%s \n", dest3); // destsrc
}
```

### strncat()

`char *strncat(char *dest, const char *src, size_t n);`

- 参数：
    - dest：目的字符串首地址
    - src：源字符首地址
    - n：指定需要追加字符串个数
- 返回值：
    - 成功：返回dest字符串的首地址
    - 失败：NULL

```c
void test_strncat(){
    char dest4[10] = "dest";
    char src4[] = "src";
    strncat(dest4, src4, 2);
    printf("%s \n", dest4); // destsr
}
```

### strcmp()

`int strcmp(const char *s1, const char *s2);`

比较 s1 和 s2 的大小，比较的是字符 ASCII 码大小。

- 参数：
    - s1：字符串1首地址
    - s2：字符串2首地址
- 返回值：
    - 相等：0
    - 大于：>0
    - 小于：<0

```c
printf("%d \n", strcmp("hello", "hello")); // 0
printf("%d \n", strcmp("hell", "hello")); // -1
printf("%d \n", strcmp("hello", "hell")); // 1
```

### strncmp()

`int strncmp(const char *s1, const char *s2, size_t n);`

比较 s1 和 s2 前 n个字符的大小，比较的是字符 ASCII 码大小。

- 参数：
    - s1：字符串1首地址
    - s2：字符串2首地址
    - n：指定比较字符串的数量
- 返回值：
    - 相等：0
    - 大于：>0
    - 小于：<0

```c
printf("%d \n", strncmp("hello", "hello", 2)); // 0
printf("%d \n", strncmp("hell", "hello", 2)); // 0
printf("%d \n", strncmp("hello", "hell", 2)); // 0
```

### sprintf()

`int sprintf(char *str , const char *format, ...);`

根据参数 format 字符串来转换并格式化数据，然后将结果输出到 str 指定的空间中，直到出现字符串结束符 '\0' 为止。

- 参数：
    - str：字符串首地址
    - format：字符串格式，用法和printf()一样
- 返回值：
    - 成功：实际格式化的字符个数
    - 失败： - 1

```c
char buf[100];
sprintf(buf, "%d%c%d=%d \n", 10, '+', 20, 10 + 20);
printf("%s \n", buf); // 10+20=30
```

### sscanf()

`int sscanf(const char *str, const char *format, ...);`

从 str 指定的字符串读取数据，并根据参数 format 字符串来转换并格式化数据。

- 参数：
    - str：指定的字符串首地址
    - format：字符串格式，用法和scanf()一样
- 返回值：
    - 成功：参数数目，成功转换的值的个数
    - 失败： - 1

```c
int a, b, c;
char buf2[] = "10+20=30";
sscanf(buf2, "%d+%d=%d", &a, &b, &c);
printf("a=%d \n", a);
printf("b=%d \n", b);
printf("c=%d \n", c);
```

### strchr()

`char *strchr(const char *s, int c);`

在字符串 s 中查找字母 c 出现的位置

- 参数：
    - s：字符串首地址
    - c：匹配字母(字符)
- 返回值：
    - 成功：返回第一次出现的c地址
    - 失败：NULL

```c
printf("%s \n", strchr("hello", 'e')); // ello
printf("%s \n", strchr("hello", 'a')); // null

// strrchr:从右向左开始找，输出后面的内容
printf("%s \n", strrchr("hello", 'e')); // ello
```

### strstr()

`char *strstr(const char *haystack, const char *needle);`

在字符串 haystack 中查找字符串 needle 出现的位置

- 参数：
    - haystack：源字符串首地址
    - needle：匹配字符串首地址
- 返回值：
    - 成功：返回第一次出现的needle地址
    - 失败：NULL

```c
// 在字符串中找子串第一次出现的位置，返回地址
printf("%s \n", strstr("hello", "el")); // ello
```

### strtok()

`char *strtok(char *str, const char *delim);`

字符串切割，将拆分的字符用 \0 替换

```c
char str[80] = "www.baidu.com";

/* 获取第一个子字符串 */
char *token = strtok(str, ".");

// char *token = strtok("www.baidu.com", "."); // 错误使用，参数一不能是常量

printf("%s\n", token); // www

/* 继续获取其他的子字符串 */
while (token != NULL) {
	printf("%s\n", token);
  token = strtok(NULL, "."); // 传递剩余的字符串
}
```

### atoi()

`int atoi(const char *nptr);`

atoi() 会扫描 nptr 字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符('\0')才结束转换，并将结果返回返回值。

```c
char ss[] = "10";
int num_ss = atoi(ss);
printf("%d \n", num_ss); // 10

/**
* 字符串转小数
*/
char sss[] = "0.123";
double num_sss = atof(sss);
printf("%f \n", num_sss); //0.123000

/**
* 字符串转长整数
*/
char ssss[] = "-10L";
long num_ssss = atol(ssss);
printf("%ld \n", num_ssss); // -10
```
