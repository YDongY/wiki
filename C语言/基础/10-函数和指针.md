---
title: 10-函数和指针
description: 
published: true
date: 2021-02-21T13:37:33.386Z
tags: 
editor: undefined
dateCreated: 2021-02-21T13:24:07.162Z
---

# 函数和指针

{{< details title="要点回顾：" open=true >}}

1. 指针是一种数据类型
2. 指针变量存放地址
3. &可以取得一个变量在内存中的地址。但是，不能取寄存器变量，因为寄存器变量不在内存里，而在 CPU 里面，所以是没有地址的
4. 不同类型的指针变量，指针大小相同
5. 野指针指向非法内存
6. 空指针指向 NULL
7. const 修饰的指针变量，向右修饰，被修饰的只读
8. 函数形参接收指针，可以修改实参是值
9. 数组名作为实参传递，实际传递是地址
10. 函数不要返回局部变量指针，因为函数调用完毕，栈空间回收，返回指针是野指针

{{< /details >}}

## 函数

### 函数分类

- 系统函数，即库函数：这是由编译系统提供的，用户不必自己定义这些函数，可以直接使用它们，如我们常用的打印函数 printf()。
- 用户定义函数：用以解决用户的专门需要。

### 函数名字、形参、函数体、返回值

- 函数名的后面有个圆换号()，代表这个为函数
- 函数定义中圆括号内列表中出现的变量称为形式参数，在未出现函数调用时，它们并不占内存中的存储单元

```c
void max(int a, int b){ // 类型加形参
	// ...
}

void max(){ // 没形参， 圆括号内容为空
	// ...
}

void max(void){ // 没形参， 圆括号内容为void关键字
	// ...
}
```

- 函数调用中与形式参数对应的值称为实际参数
- 尽量保证 return 语句中表达式的值和函数返回类型是同一类型。如果函数返回的类型和 return 语句中表达式的值不一致，则以函数返回类型为准，即函数返回类型决定返回值的类型。对数值型数据，可以自动进行类型转换

### 函数的形参和实参

- 形参出现在函数定义中，实参出现在主调函数中
- 实参变量对形参变量的数据传递是“值传递”，即单向传递，只由实参传给形参，而不能由形参传回来给实参。
- 在调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放。

### 函数调用

```c
// 函数的定义
void test(){} // 无参无返回值

int test2{ // 无参有返回值
	return 0;
} 

void test(int a){} // 有参无返回值

int test(int a){ // 有参有返回值
	return 0;
}
```

### 函数声明

如果使用用户自己定义的函数，而该函数与调用它的函数（即主调函数）不在同一文件中，或者函数定义的位置在主调函数之后，则必须在调用此函数之前对被调用的函数作声明。

所谓函数声明，就是在函数尚在未定义的情况下，事先将该函数的有关信息通知编译系统，相当于告诉编译器，函数在后面定义，以便使编译能正常进行。

```c
#include <stdio.h>

int add(int x, int y); // 函数声明

int main(int argc, char const *argv[]) {
    int a = 10;
    int b = 20;
    int sum = add(a, b); // 函数调用
    printf("%d", sum); // 30

    return 0;
}

int add(int x, int y) { // 函数定义
    return x + y;
}
```

## 指针

### 指针变量

- 内存区的每一个字节都有一个编号，这就是“地址”。
- 如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)
- 指针的实质就是内存“地址”。指针就是地址，地址就是指针。
- 指针是内存单元的编号，指针变量是存放地址的变量。

```c
----------------------------------------------
| 变量 |   内存地址    |         字节           |
----------------------------------------------
|     |0x7ffd822cbe48|  |  |  |  |  |  |  |  |  \
|     |0x7ffd822cbe49|  |  |  |  |  |  |  |  |   \
| b   |0x7ffd822cbe4A|  |  |  |  |  |  |  |  |   / 32bit <---
|     |0x7ffd822cbe4B|  |  |  |  |  |  |  |  |  /           |
----------------------------------------------              |
                                                            |
0x7fff7e7433e0(p)                 0x7ffd822cbe48(b)         |
--------------------              ---------------           |
| 0x7ffd822cbe48   |  --------->  |     10      |------------
--------------------              ---------------

int b = 10;
printf("%p \n", &b); // 0x7ffd822cbe48
```

### 指针变量的定义和使用

- 指针也是一种数据类型，指针变量也是一种变量
- 指针变量指向谁，就把谁的地址赋值给指针变量
- `*`操作符操作的是指针变量指向的内存空间

```c
int b = 10;
// 指针类型的变量 p 存放 整型变量 b 的内存地址
int *p = &b; // int * 表示指针类型，p 是变量名
printf("%p\n", p); // 0x7ffd822cbe48，获取地址
printf("%d\n", *p); // 10，获取地址存储的数据

char *p1 = &b;
printf("%c\n", *p1);// *p1指向了 b 的地址，*p1就是 b 的值
```

注意：&可以取得一个变量在内存中的地址。但是，不能取寄存器变量，因为寄存器变量不在内存里，而在 CPU 里面，所以是没有地址的。

### 通过指针间接修改变量的值

```c
int a = 0;
int b = 11;
int *p = &a; // p 存放 a 的地址

*p = 100; // 修改 *p 的指向地址空间的值，即修改变量 a 的值为 100
printf("a = %d, *p = %d\n", a, *p); // a = 100, *p = 100

p = &b; // p 存放 b 的地址
*p = 22; // 修改 *p 的指向地址空间的值，即修改变量 b 的值为 22
printf("b = %d, *p = %d\n", b, *p); // b = 22, *p = 22
```

### 指针大小

- 使用 sizeof() 测量指针的大小，得到的总是：4 或 8
- sizeof() 测的是指针变量指向存储地址的大小
- 在 32 位平台，所有的指针（地址）都是 32 位( 4 字节)
- 在 64 位平台，所有的指针（地址）都是 64 位( 8 字节)

```c
#include <stdio.h>

int main(int argc,char const *argv[]){
	char *p;
	int *p1;
	double *p2;
	
	printf("sizeof(p) = %d\n", sizeof(p)); // 8
	printf("sizeof(p1) = %d\n", sizeof(p1)); // 8
	printf("sizeof(p2) = %d\n", sizeof(p2)); // 8
}
```

### 野指针和空指针

任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。

```c
int a = 100;
int *p;
p = a; //把a的值赋值给指针变量p，p为野指针， ok，不会有问题，但没有意义

p = 0x12345678; //给指针变量p赋值，p为野指针， ok，不会有问题，但没有意义

*p = 1000;  //操作野指针指向未知区域，内存出问题，err
```

但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把 NULL 赋值给此指针，这样就标志此指针为空指针，没有任何指针

```c
int *p = NULL;
```

NULL 是一个值为 0 的宏常量：

```c
#define NULL    ((void *)0)
```

### 万能指针 void*

void * 指针可以指向任意变量的内存空间：

```c
void *p = NULL;

int a = 10;
p = (void *)&a; //指向变量时，最好转换为void *

//使用指针变量指向的内存时，转换为int *
*((int *)p) = 11;
printf("a = %d\n", a);
```

### const 修饰的指针变量

```c
const int *p2; // *p2 不能修改，可以修改 p2

int const *p3; // *p3 不能修改，可以修改 p3

int * const p4; // 可以修改 *p4 ，不能修改 p4

const int * const p5; // 不可以修改 *p4 ，也不能修改 p4

// 总结：const 向右修饰，被修饰的只读
```

## 字符指针

```c
// -- 字符串变量，可读可写
char str1[] = {'h','e','l','l','o','\0'};
char str11[] = "hello"; // {'h','e','l','l','o','\0'}

// -- 字符串常量，只读
char *str2 = "hello"; // 字符串常量

// 字符串做参数
void func(char str[]);
void func(char *str);
```

### 指针数组做为 main 函数的形参

```c
int main(int argc, char *argv[]);
```

- main 函数是操作系统调用的，第一个参数标明 argv 数组的成员数量，argv 数组的每个成员都是 char *类型
- argv 是命令行参数的字符串数组

## 多级指针

- C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针。
- 二级指针就是指向一个一级指针变量地址的指针。

```c
int a = 0;
int *p = &a; // 一级指针
int **pp = &p; // 二级指针
int ***ppp = &pp; // 三级指针
```

## 指针函数传参

### 函数形参改变实参的值

```c
#include <stdio.h>

void swap(int a, int b);

void swap2(int *a, int *b);

int main(int argc, char const *argv[]) {
    int m = 10;
    int n = 20;

    swap(m, n); // 实参 --> 形参，值拷贝

    printf("%d %d \n", m, n); // 10 20

    swap2(&m, &n); // 地址拷贝

    printf("%d %d \n", m, n); // 20 10
}

void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

void swap2(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
```

### 数组名做函数参数

数组名做函数参数，函数的形参会退化为指针：

```c
#include <stdio.h>

// void print(int arr[10], int len);
// void print(int *arr, int len);
void print(int arr[], int len);

int main(int argc, char const *argv[]) {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int len = sizeof(arr) / sizeof(int);
    print(arr, len); // //数组名做函数参数
}

void print(int arr[], int len) { // 相当于 int *arr
    for (int i = 0; i < len; i++) {
        printf("%d \t", arr[i]);
    }
}
```

### 指针做为函数的返回值

```c
#include <stdio.h>

int m = 100;

int *func() {
    // printf("%p \n", &m);
    // return &m;

    // int a = 1000;
    // return &a; // 不能返回局部变量
}

int main(int argc, char const *argv[]) {
    int *p;

    p = func();

    printf("%p \n", p);
}
```
