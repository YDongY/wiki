---
title: 01-基础
description: 
published: true
date: 2021-03-09T07:20:07.106Z
tags: c
editor: markdown
dateCreated: 2021-02-21T14:38:31.735Z
---

# 第一个 C 程序

使用 C 语言实现 Hello World 程序：

```c
#include <stdio.h>

// 有且只有一个 main 函数，程序运行入口
int main()
{
    printf("hello world\n");
    return 0;
}
```

> 程序 `return 0` 的作用是把返回值传递给父进程。如果取消 `return 0` ，返回值是 printf 函数的返回值，但也有可能是 0。
{.is-info}


## GCC 编译

1. 预处理：宏定义展开、头文件展开、条件编译、去除注释，不做语法检查
2. 编译：检查语法，将预处理后文件编译生成汇编文件
3. 汇编：将汇编文件生成目标文件（二进制文件）
4. 链接：链接依赖库生成最终可执行程序（`ldd xxx`可以查看动态库）

```bash
$ ldd a.out
linux-vdso.so.1 (0x00007ffc76193000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007efc786e1000)
/lib64/ld-linux-x86-64.so.2 (0x00007efc788c3000)
```

### 分步编译

- 预处理：`gcc -E hello.c -o hello.i`
- 编译：`gcc -S hello.i -o hello.s`
- 汇编目标代码：`gcc -c hello.s -o hello.o`
- 链接：`gcc hello.o -o hello`

### 一步编译

```bash
$ gcc hello.c -o hello
```

### 反汇编

```bash
$ gcc -S hello.c -o hello.s
```

# 标识符、变量和常量

> 1. 变量声明，不会开辟内存空间
> 2. 变量定义，会开辟内存空间
> 3. 常量不能修改

## 标识符

- 标识符不能是关键字
- 标识符只能由字母、数字、下划线组成
- 第一个字符必须为字母或下划线，下划线“_”被看做是字母，通常用于命名较长的变量名，一般不要以下划线开头
- 标识符中字母区分大小写
- 传统用法，变量名使用小写字母，符号常量名全部使用大写字母。

## 变量

- 在程序运行过程中，其值可以改变
- 变量在使用前必须先定义，定义变量前必须有相应的数据类型
- 变量在编译时为其分配相应的内存空间
- 可以通过其名字和地址访问相应内存

```c
[存储类型] 数据类型 标识符 = 值;
          TYPE NAME = VALUE;
```

- 数据类型：基本数据类型、构造类型

- 存储类型
	- `auto`：默认，没有初始化功能。自动分配空间，自动回收空间（放在栈空间）
  - `static`：静态型。自动初始化为 0 或空值，并且值具有继承性。常用于修饰变量或函数，全局 static 作用范围仅限于当前文件。
  - `register`：寄存器类型，只能用来定义局部变量，大小有限制（32 位 OS 定义 32 位大小的数据类型），没有地址无法打印
  - `extern`（说明型）：意味着不能改变被说明的变量的值或类型

变量定义与声明：

- 声明变量不需要建立存储空间，如：`extern int a;`
- 定义变量需要建立存储空间，如：`int b =10;`

```c
#include <stdio.h>

int main()
{
	// extern 关键字只做声明，不能做任何定义
	// 声明一个变量 a，a 在这里没有建立存储空间
	extern int a;
	a = 10;	// err, 没有空间，就不可以赋值

	int b = 10;	//定义一个变量 b，b 的类型为 int，b 赋值为 10

	int c; // 既是声明，同时又是定义

	return 0;
}
```

## 常量

- 在程序运行过程中，其值不能被改变
- 常量一般出现在表达式或赋值语句中

常量类型：

- 整数常量：`1234、123456789L、100u、200U、11111111UL`
- 浮点数常量：`123.4、1e-2、0.8888f、3.1415926l`
- 字符常量：由单引号引起来的单个字符或转义字符，`'a'、'\n'`
- 字符串常量：由双引号引起来的一个或多个字符序列，`"a"、"hello"、""（包括一个尾0）、"abc\n\021\018"`

> `\018`：错误的，因为三个数字表示八进制，而八进制不能包含 8。最终解释为 `\0` 和 '8'
{.is-info}

- 标识常量：`#define PI 3.14` ，预处理之后宏名会被宏体所替换，不做语法检查。不能出现在赋值符的左侧。

例如：

```c
#define PI 3.14abc
int main() {
  int a = 10;
  print("%f", a * PI); // 使用宏定义
#define INIT_TYPE(TYPE, NAME) \
    do { \
        if (TYPE < 0) { \
            return NAME; \
        } \
    } while (0)

  INIT_TYPE(10, "10");
  INIT_TYPE(20, "20");
#undef INIT_TYPE
}
```

```shell
$ gcc -E xxx.c

int main() {
  int a = 10;
  print("%f", a * 3.14abc); // 直接替换，不检查语法
# 24 "c1.1.c"
  do { if (10 < 0) { return "10"; } } while (0); // 直接替换
  do { if (20 < 0) { return "20"; } } while (0); // 直接替换
}
```

# 关键字和 sizeof

> 1. 给变量或者常量起名称时候，不要使用关键字，否则会产生歧义
> 2. sizeof 不是函数，用于计算一个数据类型大小，单位字节

## 关键字

| 数据类型关键字 | 控制语句关键字 | 存储类关键 | 其他关键字 |
| :------------: | :------------: | :--------: | :--------: |
|     `char`     |      `if`      |   `auto`   |  `sizeof`  |
|    `short`     |     `else`     |  `extern`  | `typedef`  |
|     `int`      |    `switch`    | `register` | `volatile` |
|     `long`     |     `for`      |  `static`  |            |
|    `float`     |     `case`     |  `const`   |            |
|    `double`    |   `default`    |            |            |
|   `unsigned`   |      `do`      |            |            |
|    `struct`    |    `break`     |            |            |
|    `union`     |   `continue`   |            |            |
|     `enum`     |     `goto`     |            |            |
|     `void`     |    `return`    |            |            |

## sizeof

- sizeof 不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为**字节**
- sizeof 的返回值为 size_t
- size_t 类型在 32 位操作系统下是 `unsigned int`，是一个无符号的整数

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{

    int i1 = 10;
    int i2 = 20;
    int size = sizeof(i1);
    printf("%d \n", size); // 4
    printf("%d \n", sizeof i1); // 4，不推荐
    printf("%d \n", sizeof(int)); // 4

    // 查看内存地址
    printf("%p \n",&i1); // 0x7fffb3da3468
    printf("%p \n",&i2); // 0x7fffb3da3464

    printf("sizeof(char) = %u \n", sizeof(char)); // sizeof(char) = 1
    int a;
    printf("sizeof(a) = %u \n", sizeof(a)); // sizeof(a) = 4
    return 0;
}
```

# 数据类型

> 1. short 类型通常为 16 位，long 类型通常为 32位，int 类型可以为 16 位或 32 位。各编译器可以根据硬件特性自主选择合适的类型长度，但要遵循下列限制： short 与 int 类型至少为 16 位， 而 long 类型至少为 32 位， 并且 short 类型不得长于 int 类型，int 类型不得长于 long 类型
> 2. 字符型本质存放的是 ASCII 码
> 3. 不同类型之间运算，是低精度与高精度进行运算默认向高精度靠拢。同时浮点型转强换为整型是直接丢掉小数，而不是四舍五入

![数据类型.png](/C语言/数据类型.png)

## 整型

- 有符号数是最高位为符号位，0代表正数，1代表负数。
- 无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。

C 语言表示：

- 十进制：254
- 二进制：B11111110（**C 语言不支持二进制表示**）
- 八进制：0376
- 十六进制：0xFE

| 类型                 | 存储大小    | 值范围                                      |
| :------------------- | :---------- | :------------------------------------------ |
| `int`                | 2 或 4 字节 | -32768 - 32767 或 -2147483648  - 2147483647 |
| `unsigned int`       | 2 或 4 字节 | 0 - 65535 或 0 - 4294967295                 |
| `short`              | 2 字节      | -32768 - 32767                              |
| `unsigned short`     | 2 字节      | 0 - 65535                                   |
| `long`               | 4 字节      | -2147483648 - 2147483647                    |
| `unsigned long`      | 4 字节      | 0 - 4294967295                              |
| `long long`          | 8 字节      | -9223372036854775808 - 9223372036854775807  |
| `unsigned long long` | 8 字节      | 0 - 18446744073709551615                    |

## 打印格式

| 打印格式          | 含义                                                    |     |
| ----------------- | ------------------------------------------------------- | --- |
| `%d`              | 输出一个有符号的 10 进制 int 类型                       |     |
| `%o`              | 输出 8 进制的 int 类型                                  |     |
| `%x`              | 输出 16 进制的 int 类型，字母小写                       |     |
| `%X`              | 输出 16 进制的 int 类型，字母大写                       |     |
| `%u`              | 输出 unsigned int 类型                                  |     |
| `%l` 或者 `%ll`   | 输出 long 类型 或者 输出 unsigned  long 类型            |     |
| `%lu` 或者 `%llu` | 输出 long  long 类型 或者 输出 unsigned long  long 类型 |     |
| `%hd` 或者 `%hu`  | 输出 short 类型 或者 输出 unsigned short 类型           |     |
| `%f`              | float 输出单精度浮点数                                  |     |
| `%lf`             | double 输出双精度浮点数                                 |     |
| `%e`或者`%E`      | double 科学计数法                                       |     |
| `%s`              | 字符串，输出字符串中的字符直到字符串中的空字符          |     |
| `%c`              | 字符型                                                  |     |
| `%p`              | 以 16 进制形式输出指针                                  |     |
| `%%`              | 输出一个百分号                                          |     |

## 字符型

- 字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节。
- 单引号(' ')把字符括起来

> 字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。char 的本质就是一个 1 字节大小的整型。
{.is-info}


### 字符变量输出

```c
#include <stdio.h>

int main(){
    char ch = 'a';
    printf("sizeof(ch) = %u\n", sizeof(ch));

    printf("ch[%%c] = %c\n", ch); // 打印字符
    printf("ch[%%d] = %d\n", ch); // 打印‘a’ ASCII的值

    char A = 'A';
    char a = 'a';
    printf("a = %d\n", a); // 97
    printf("A = %d\n", A); // 65

    printf("A = %c\n", 'a' - 32); // 小写a转大写A
    printf("a = %c\n", 'A' + 32); // 大写A转小写a

    ch = ' ';
    printf("空字符：%d\n", ch); // 空字符ASCII的值为32
    printf("A = %c\n", 'a' - ' '); // 小写a转大写A
    printf("a = %c\n", 'A' + ' '); // 大写A转小写a

    return 0;
}
```

### 字符变量输入

```c
#include <stdio.h>

int main(){
    char ch;
    printf("请输入ch的值：");

    // 不要加 “\n” 
    scanf("%c", &ch);
    printf("ch = %c\n", ch); //打印ch的字符

    return 0;
}
```

### 转义字符

| 转义字符 | 含义                                | ASCII码值（十进制） |
| -------- | ----------------------------------- | ------------------- |
| \a       | 警报                                | 007                 |
| \b       | 退格(BS) ，将当前位置移到前一列     | 008                 |
| \f       | 换页(FF)，将当前位置移到下页开头    | 012                 |
| \n       | 换行(LF) ，将当前位置移到下一行开头 | 010                 |
| \r       | 回车(CR) ，将当前位置移到本行开头   | 013                 |
| \t       | 水平制表(HT) （跳到下一个TAB位置）  | 009                 |
| \v       | 垂直制表(VT)                        | 011                 |
| \\\      | 代表一个反斜线字符"\\"              | 092                 |
| \\\'     | 代表一个单引号（撇号）字符          | 039                 |
| \\"      | 代表一个双引号字符                  | 034                 |
| \?       | 代表一个问号                        | 063                 |
| \0       | 数字0                               | 000                 |
| \ddd     | 8进制转义字符，d范围0~7             | 3 位 8 进制         |
| \xhh     | 16进制转义字符，h范围0~9，a~f，A~F  | 2 位 16 进制        |


```c
#include <stdio.h>

int main()
{
	printf("abc");
	printf("\refg\n"); // \r 切换到句首， \n 为换行键

	printf("abc");
	printf("\befg\n");// \b 为退格键， \n 为换行键

	printf("%d\n", '\123');// '\123'为 8 进制转义字符，0123 对应 10 进制数为 83
	printf("%d\n", '\x23');// '\x23'为 16 进制转义字符，0x23 对应 10 进制数为 35

	return 0;
}
```

## 浮点型

实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的，在 C 语言中， 浮点型变量分为两种： 单精度浮点数(float)、 双精度浮点数(double)， 但是 double 型变量所表示的浮点数比 float 型变量更精确。

表示：

- 3.14
- 0.314 * 10 ^1
- 314 * 10^(-2)

有三部分组成：**符号位 + 指数位 + 精度部分（小数部分）**

**浮点类型（IEEE 754）**

| 类型        | 存储大小 | 值范围                | 精度      |
| :---------- | :------- | :-------------------- | :-------- |
| float       | 4 字节   | -3.4E-38  - 3.4E+38    | 6 位小数  |
| double      | 8 字节   | -1.8E-308 - 1.8E+308   | 15 位小数 |
| long double | 16 字节  | -1.2E-4932 - 1.2E+4932 | 19 位小数 |


不以 f 结尾的常量是 double 类型，以 f 结尾的常量(如3.14f)是 float 类型。

```c
#include <stdio.h>

int main(){
		// 传统方式赋值
    float a = 3.14f; //  或3.14F
    float b = 1.;
    float c = 1.f;
    
    printf("%f \n", a); // 3.140000
    printf("%f \n", b); // 1.000000
    printf("%f \n", c); // 1.000000
    
    double d;
    d = 3.14;
    double e = .1;

    printf("%lf \n", d); // 3.140000
    printf("%lf \n", e); // 0.100000

    // 科学法赋值
    a = 3.2e3f; // 3.2*1000 = 32000，e 可以写 E
    printf("a1 = %f\n", a);

    a = 100e-3f; // 100*0.001 = 0.1
    printf("a2 = %f\n", a);

		// 十六进制小数
    // 1.125 * 2^10
    float f5 = 0x1.2p10;
    printf("%f \n", f5); // 1152.000000
    printf("%.2f \n", f5); // 1152.00

		a = 3.1415926f; // 保留小数点后 6 位
		printf("a3 = %f\n", a); // 结果为3.141593

		return 0;
}
```


## 数值溢出

当超过一个数据类型能够存放最大的范围时，数值会溢出。符号位溢出会导致数的正负发生改变，最高位的溢出会导致最高位丢失。

```c
#include <stdio.h>

int main()
{
	char ch; // -128 到 127

	// ------- 符号位溢出会导致数的正负发生改变 ----------
	ch = 0x7f + 2; // 127+2
	printf("%d\n", ch);
	//	 0111 1111
	// +2 后 1000 0001，这是负数补码，其原码为 1111 1111，结果为-127

	// -------- 最高位的溢出会导致最高位丢失 -------------
	unsigned char ch2; // 0 到 255
	ch2 = 0xff+1; // 255+1
	printf("%u\n", ch2);
	//	  1111 1111
	// +1 后 10000 0000， char 只有 8 位最高位的溢出，结果为 0000 0000，十进制为 0

	return 0;
}
```

## 类型转换

不同类型数据之间进行混合运算时必然涉及到类型的转换，转换的方法有两种：

- 自动转换(隐式转换)：遵循一定的规则，由编译系统自动完成。
- 强制类型转换：把表达式的运算结果强制转换成所需的数据类型。

> 占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低。
> 浮点型强转整型：直接丢掉小数，不是四舍五入
{.is-info}

![类型转换.png](/C语言/类型转换.png)

### 隐式类型转换

```c
#include <stdio.h>

int main()
{
	int num = 5;
	printf("s1=%d\n", num / 2);
	printf("s2=%lf\n", num / 2.0);

	return 0;
}
```

### 强制类型转换

```c
#include <stdio.h>

int main()
{
	float x = 0;
	int i = 0;
	x = 3.6f;

	i = x;			// x 为实型, i 为整型，直接赋值会有警告
	i = (int)x;		// 使用强制类型转换

	printf("x=%f, i=%d\n", x, i);

	return 0;
}
```

### 面试题

考察 float 与整型数据的比较，没法真正比较是否相等，实际上只能取近似值。

```c
int func(float f) {
  if (f < 0) {
    return -1;
  } else if (f == 0) { // if(abs(f-0)) <=1e-6
    return 0;
  } else {
    return 1;
  }
}
```

# 进制与存储

> 1. 进制转换
> 2. 计算内部只有二进制，且数值采用补码表示
> 3. 大端模式：高字节放低地址，低字节放高地址
> 4. 小端模式：高字节放高地址，低字节放低地址

## 进制转换

- 十进制（Decimal）
- 八进制（Octal）
- 二进制（Binary）
- 十六进制（Hexadecimal）

### 任意进制转十进制

一个 R 进制数：$`k_{3}k_{2}k_{1}k_{0}.s_{1}s_{2}s_{3}`$ 转十进制

$$k_{3}*R^3 + k_{2}*R^2 + k_{1}*R^1 + k_{0}*R^0 + s_{1}*R^{-1} + s_{2}*R^{-2} + s_{3}*R^{-3}$$

### 十进制转任意进制

- 整数转换：除 R 取余法（bottom-top）
- 小数转换：乘 R 取整法（top-bottom）

### 代码书写

```c
int decimal = 24; // 十进制
int hex = 0x2B; // 十六进制
int binary = 024; // 八进制

// C 语言标准不支持二进制表示，GCC 编译器支持
int binary = 0b101010; // 二进制

printf("十进制：%d",20); // 20
printf("十进制：%i",20); // 20
printf("八进制：%o",20); // 24
printf("十六进制：%x",20); // 14
```

## 计算机内存数值存储方式

### 存储单位

- 1字 = 2B
- 1KB = 1024B = 2^10B
- 1MB = 1024KB = 2^20B
- 1GB = 1024MB = 2^30B

### 变量内存地址

由于计算机只能识别 0 和 1 ，所以每一个字节中的数据都是以二进制形式存储的。一个字节包含 8 个二进制位，每一个二进制位存储一个 0 或 1.

1Byte = 8bit ,1B = 8b

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{

    int i1 = 10;
    int i2 = 20;

    // 查看内存地址，变量首字节的内存地址
    printf("%p \n",&i1); // 0x7fffb3da3468
    printf("%p \n",&i2); // 0x7fffb3da3464

    // 先声明的 i1 内存地址大，后声明的 i2 内存地址小
}

----------------------------------------------
| 变量 |   内存地址    |         字节           |
----------------------------------------------
|     |0x7fffb3da3464|  |  |  |  |  |  |  |  |  \
|     |0x7fffb3da3465|  |  |  |  |  |  |  |  |   \
| i2  |0x7fffb3da3466|  |  |  |  |  |  |  |  |   / 32bit
|     |0x7fffb3da3467|  |  |  |  |  |  |  |  |  /
----------------------------------------------
|     |0x7fffb3da3468|  |  |  |  |  |  |  |  |  \
|     |0x7fffb3da3469|  |  |  |  |  |  |  |  |   \
| i1  |0x7fffb3da346A|  |  |  |  |  |  |  |  |   / 32bit
|     |0x7fffb3da346B|  |  |  |  |  |  |  |  |  /
----------------------------------------------
```

### 原码、反码、补码

在计算机中，数值一律采用补码来表示和存储，原因是：

① 统一了零的编码，
② 将符号位和其它位统一处理
③ 将减法运算转变为加法运算
④ 两个用补码表示数相加时，最高位符号位如果有进位，则被舍弃

```c
// 原码

 有符号数   符号位        数值位
----------------------------------------------
| +11   |   0    | 0 | 0 | 0 | 1 | 0 | 1 | 1 |
----------------------------------------------
| -11   |   1    | 0 | 0 | 0 | 1 | 0 | 1 | 1 |
----------------------------------------------

// 反码
// - 正数反码：和原码一样
// - 负数反码：原码按位取反

----------------------------------------------
| +11   |   0    | 0 | 0 | 0 | 1 | 0 | 1 | 1 |
----------------------------------------------
| -11   |   1    | 1 | 1 | 1 | 0 | 1 | 0 | 0 |
----------------------------------------------

// 补码
// - 正数补码：和原码一样
// - 负数补码：反码末位+1
----------------------------------------------
| +11   |   0    | 0 | 0 | 0 | 1 | 0 | 1 | 1 |
----------------------------------------------
| -11   |   1    | 1 | 1 | 1 | 0 | 1 | 0 | 1 |
----------------------------------------------
```

## 大小端模式

决定字节数据的字节存储顺序

```c
// 整数的补码表示

  高字节                                 低字节
-------------------------------------------------
| 0001 0001 | 0010 0010 | 0100 0100 | 1000 1000 |
-------------------------------------------------

// -------------- 大端模式 -----------------------
// 高字节放低地址，低字节放高地址

------------------------------------------------
|   内存地址    |       字节                     |
------------------------------------------------
|0x7fffb3da3464| 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 高字节
|0x7fffb3da3465| 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 |   |
|0x7fffb3da3466| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 |   |
|0x7fffb3da3467| 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 低字节
------------------------------------------------

// -------------- 小端模式 -----------------------
// 高字节放高地址，低字节放低地址

------------------------------------------------
|   内存地址    |       字节                     |
------------------------------------------------
|0x7fffb3da3464| 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 低字节
|0x7fffb3da3465| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 |   |
|0x7fffb3da3466| 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 |   |
|0x7fffb3da3467| 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 高字节
------------------------------------------------
```

# 运算符

> 1. a++，a— ：表示先使用后 +1 或 -1
> 2. —a，++a：表示先 +1 或 -1 在使用
> 3. &&：左右为真，结果为真，左边为假，右边不执行
> 4. ||：只要有一边为真，结果就为真，左边为真右边不执行

## 算术运算符

```c
int main(int argc, char const *argv[])
{
		// + - * / %
    printf("%d \n", 7 / 4);          // 1
    printf("%lf \n", (double)7 / 4); // 1.75000
    printf("%lf \n", 7.0 / 4);       // 1.75000

    printf("%d \n", 7 % 4); // 3

    // 模运算结果的正负性跟随运算符左边正负性
    printf("%d \n", 10 % 7);   // 3
    printf("%d \n", 10 % -7);  // 3
    printf("%d \n", -10 % 7);  // -3
    printf("%d \n", -10 % -7); // -3

		// a++
    // a--
    // ++a
    // --a
}
```

## 比较运算符

```c
// == != > < >= <=
// 1 表示真， 0 表示假
printf("%d \n", 4 == 3); // 0
printf("%d \n", 4 > 3);  // 1
```

## 赋值运算符

```c
// = += -= *= /= %=
int a=2 ,b=3;

// a=b;
// a+=b;
// a-=b;
// a*=b;
// a/=b;
// a%=b;
```

## 逻辑运算符

```c
// ! && ||
// &&:左右为真，结果为真，左边为假，右边不执行
printf("%d \n", 1 && -1); // 1
printf("%d \n", 1 && 0);  // 0

// ||:只要有一边为真，结果就为真，左边为真右边不执行
printf("%d \n", 1 || 0); // 1
printf("%d \n", 0 || 0); // 0
```

## 位运算

```c
#include <stdio.h>
int main(int argc, char const *argv[])
{
    // & | ~
    printf("%d \n", 10 ^ 10); // 0
    printf("%d \n", 10 ^ 0);  // 10
    printf("%d \n", -10 ^ 0); // -10

    return 0;
}
```

# 流程控制

C语言支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构。

- 顺序结构：程序按顺序执行，不发生跳转。
- 选择结构：依据是否满足条件，有选择的执行相应功能。
- 循环结构：依据条件是否满足，循环多次执行某段代码。

## if-else

```c
int main(int argc, char const *argv[]) {
    if (){
        // ...
    }else if (){
        // ...
    }else{
        // ...
    }

    // 省略 {}
    if ()
        // ...
    else
        // ...
		
		// 三目运算符
		c = ( a > b ? a : b );
    return 0;
}
```

## switch

- 可以没有 default
- 表达式、表达式1、表达式2必须是整型表达式
- 表达式1、表达式2必须是常量表达式，不能带有变量

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    switch ("表达式"){
        case "表达式1":
            // ...
            break;
        case "表达式2":
            // ...
            break;
        default: // 如果上面的条件都不满足，那么执行default
            break;
    }

    int a = 10;
    switch(a){
        case 1:{
            int b = 25; // case 中声明变量，必须添加 {}
            printf("%d",b);
            break;
        }
        case 2:
            printf("2");
            break;
    }
    return 0;
}
```

## while

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int i = 0;
    while (i <= 10){
        printf("%d \n", i);
        i += 1;
    }

    return 0;
}
```

## for

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    /* code */
    for (int i = 0; i <= 10; i++)
    {
        printf("%d", i);
    }
    return 0;
}
```

## do-while

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    do
    {
        printf("直接执行,在判断");
    } while (0);

    return 0;
}
```

## goto

> goto 无条件跳转，但不能跨函数跳转
{.is-info}

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int n = 0;
    code:
        printf("%d", n);
        n++;
        if (n <= 5)
            goto code; // 直接跳转到 code
    return 0;
}
```

## 死循环

```c
while(1);
for(;;);
```











